package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "parse error: %v\n", err)
		os.Exit(1)
	}

	var services []string
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if fn, ok := decl.(*ast.FuncDecl); ok && fn.Name.Name == "init" {
					for _, stmt := range fn.Body.List {
						if expr, ok := stmt.(*ast.ExprStmt); ok {
							if call, ok := expr.X.(*ast.CallExpr); ok {
								if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
									if sel.X.(*ast.Ident).Name == "cobweb" && sel.Sel.Name == "Register" {
										if arg, ok := call.Args[0].(*ast.CallExpr); ok {
											if ident, ok := arg.Fun.(*ast.Ident); ok && ident.Name == "new" {
												if typeIdent, ok := arg.Args[0].(*ast.Ident); ok {
													services = append(services, typeIdent.Name)
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	tmpl := template.Must(template.New("js").Funcs(template.FuncMap{
		"lowercase": strings.ToLower,
	}).Parse(jsTemplate))

	f, err := os.Create("./static/cobweb.js")
	if err != nil {
		fmt.Fprintf(os.Stderr, "create file error: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	err = tmpl.Execute(f, struct{ Services []string }{services})
	if err != nil {
		fmt.Fprintf(os.Stderr, "template error: %v\n", err)
		os.Exit(1)
	}
}

const jsTemplate = `// Generated by cobweb-generate
const cobweb = {
    ws: null,
    nextId: 0,
    callbacks: {},
    messageQueue: [], // Queue for messages sent before the connection is open

    connect(url) {
        this.ws = new WebSocket(url);

        // When the connection opens, send queued messages
        this.ws.onopen = () => {
            console.log("WebSocket connection established.");
            while (this.messageQueue.length > 0) {
                const msg = this.messageQueue.shift();
                this.ws.send(msg);
            }
        };

        // Handle incoming messages
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'publish') {
                const cb = this.callbacks[data.topic];
                if (cb) cb(data.data);
            } else if (data.id !== undefined) {
                const cb = this.callbacks[data.id];
                if (cb) {
                    delete this.callbacks[data.id];
                    cb(data.error, data.result);
                }
            }
        };

        // Reconnect on close
        this.ws.onclose = () => {
            console.log("WebSocket connection closed. Reconnecting in 1 second...");
            setTimeout(() => this.connect(url), 1000);
        };

        // Log errors for debugging
        this.ws.onerror = (error) => {
            console.error("WebSocket error:", error);
        };
    },

    // Send a message, queuing it if the connection isn’t open
    sendWhenReady(msg) {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(msg);
        } else {
            this.messageQueue.push(msg);
        }
    },

    subscribe(topic, callback) {
        this.callbacks[topic] = callback;
        const req = { jsonrpc: "2.0", method: "System.Subscribe", params: topic, id: this.nextId++ };
        this.sendWhenReady(JSON.stringify(req));
    },

    unsubscribe(topic) {
        delete this.callbacks[topic];
        const req = { jsonrpc: "2.0", method: "System.Unsubscribe", params: topic, id: this.nextId++ };
        this.sendWhenReady(JSON.stringify(req));
    },

    // Service methods
    {{range $service := .Services}}
    {{$service | lowercase}}Call(method, params, callback) {
        const req = { jsonrpc: "2.0", method: "{{$service}}." + method, params: params, id: this.nextId++ };
        this.callbacks[req.id] = callback;
        this.sendWhenReady(JSON.stringify(req));
    },
    {{end}}
};
`
